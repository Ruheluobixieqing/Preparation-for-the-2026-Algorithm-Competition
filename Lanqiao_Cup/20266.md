# 20266.社区服务

- 这题思路还是挺好想的，双指针同时遍历找 1 即可
- 我还多想了一会儿能不能优化一下，例如顺着扫一遍再逆着扫一遍，两次取较小值，就可以 O(n) 解决
- 后来感觉还是挺麻烦的，这个数据量暴力也没什么问题

```cpp
#include <bits/stdc++.h>
#define ll long long
const int N = 5e3+4;

int main()
{
    std::ios::sync_with_stdio(false),std::cin.tie(nullptr),std::cout.tie(nullptr);
    int n;
    std::cin>>n;
    std::string s;
    std::cin>>s;
    std::vector<int> v;
    bool find = false;
    for (int i = 0; i < n; i++)
    {
        int k = s[i] - '0';
        find = find || k;
        v.push_back(k);
    }
    if (!find)
    {
        std::cout<<-1<<'\n';
        return 0;
    }
    for (int i = 0; i < n; i++)
    {
        if (v[i]) continue;
        int left = i - 1,right = i + 1;
        while (1)
        {
            if (left >= 0)
            {
                if (v[left] == 1)
                {
                    std::cout<<i - left<<" ";
                    break;
                }
                else left--;
            }
            if (right < n)
            {
                if (v[right] == 1)
                {
                    std::cout<<right - i<<" ";
                    break;
                }
                else right++;
            }
        }
    }
    return 0;
}
```

- 交上去发现还有 20% 没过
- 其实读题的时候我就有疑问，没有找到的情况需要输出 -1，但是 -1 是否需要多次输出呢？
- 因此我猜测就是这个原因，因为不涉及超时
- 我只输出了一次，可能每个 0 都需要输出一次 -1，不过我感觉多余了，因为只要有一个找不到 1，其他的肯定也找不到 1,输出一次 -1 其实就可以了
- 简单改了一下，发现确实是要求输出多次 -1

```cpp
#include <bits/stdc++.h>
#define ll long long
const int N = 5e3+4;

int main()
{
    std::ios::sync_with_stdio(false),std::cin.tie(nullptr),std::cout.tie(nullptr);
    int n;
    std::cin>>n;
    std::string s;
    std::cin>>s;
    std::vector<int> v;
    bool find = false;
    int num = 0;
    for (int i = 0; i < n; i++)
    {
        int k = s[i] - '0';
        find = find || k;
        num += k == 0 ? 1 : 0;
        v.push_back(k);
    }
    if (!find)
    {
        for(int i = 1 ; i <= num ;i++) std::cout<<-1<<' ';
        std::cout<<'\n';
        return 0;
    }
    for (int i = 0; i < n; i++)
    {
        if (v[i]) continue;
        int left = i - 1,right = i + 1;
        while (1)
        {
            if (left >= 0)
            {
                if (v[left] == 1)
                {
                    std::cout<<i - left<<" ";
                    break;
                }
                else left--;
            }
            if (right < n)
            {
                if (v[right] == 1)
                {
                    std::cout<<right - i<<" ";
                    break;
                }
                else right++;
            }
        }
    }
    std::cout<<'\n';
    return 0;
}
```