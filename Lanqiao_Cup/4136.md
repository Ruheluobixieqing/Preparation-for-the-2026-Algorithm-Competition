# 4136.鸡哥的冒险之旅

用并查集确定每一个格子的最终收敛位置即可

```cpp
#include <bits/stdc++.h>
const int N = 205;
std::vector<std::vector<std::pair<int, int>>> pre(N, std::vector<std::pair<int, int>>(N));

std::pair<int, int> getRoot(int x, int y)
{
    if (pre[x][y].first == x && pre[x][y].second == y) return std::make_pair(x, y);
    else return getRoot(pre[x][y].first, pre[x][y].second);
}

int main()
{
    std::ios::sync_with_stdio(false), std::cin.tie(nullptr), std::cout.tie(nullptr);
    int n, m;
    std::cin >> n >> m;
    std::vector<std::vector<int>> v(n+3, std::vector<int>(m+3, INT_MAX));
    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) std::cin >> v[i][j], pre[i][j] = std::make_pair(i, j);
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            int magic = v[i][j];
            for (int _i = -1; _i <= 1; _i++)
            {
                for (int _j = -1; _j <= 1; _j++)
                {
                    if (v[i+_i][j+_j] < magic)
                    {
                        magic = v[i+_i][j+_j];
                        pre[i][j] = getRoot(i+_i, j+_j);
                    }
                }
            }
        }
    }
    std::vector<std::vector<int>> ans(n+1, std::vector<int>(m+1, 1));
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1;j <= m; j++)
        {
            ans[i][j] --;
            int x = getRoot(i, j).first, y = getRoot(i, j).second;
            ans[x][y] ++;
        }
    }
    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) std::cout << ans[i][j] << " \n"[j == m];
    return 0;
}
```