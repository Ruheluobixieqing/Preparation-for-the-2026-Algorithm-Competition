# 18483.矿石样本分析

- 这题卡了相当久，虽然是个简单题，但是感觉其实没有那么好解决的
- 我没有尝试纯暴力能否解决，不过我感觉那样效率未免过于低了，而且看数据到了 2e5，应该是需要优化一点的
- 先看看我的第一份代码
- 这里我是考虑记录每一个数字从左到右和从右到左分别第一次出现的位置在哪里
- 然后看看另一个答案是否存在，存在就找到它然后计算时间

```cpp
#include <bits/stdc++.h>
#define ll long long
#define inf LONG_LONG_MAX
const int N = 5e3+4;

int main()
{
    std::ios::sync_with_stdio(false),std::cin.tie(nullptr),std::cout.tie(nullptr);
    ll n,k;
    std::cin>>n>>k;
    std::vector<ll> v;
    v.push_back(-1);
    for (int i = 0; i < n; i ++)
    {
        ll num;
        std::cin>>num;
        v.push_back(num);
    }
    // l_to_r 记录每个数从左到右第一次出现的位置，r_to_l 则记录从右到左
    std::map<ll,ll> l_to_r,r_to_l;
    for (int i = 1; i <= n; i ++)
    {
        if (!l_to_r[v[i]]) l_to_r[v[i]] = i;
        r_to_l[v[i]] = n - i + 1;
    }
    ll ans = inf;
    for (int i = 1; i <= n; i++)
    {
        if (l_to_r.find(k-v[i]) != l_to_r.end())
        {
            ll mn1 = std::min(l_to_r[v[i]],r_to_l[v[i]]);
            ll mn2 = std::min(l_to_r[k-v[i]],r_to_l[k-v[i]]);
            ans = std::max(mn1,mn2);
        }
    }
    if (ans != inf) std::cout<<ans<<'\n';
    else std::cout<<-1<<'\n';
    return 0;
}
```

- 上面的这份没过，于是又改了一下，三种情况分开套路

```cpp
#include <bits/stdc++.h>
#define ll long long
#define inf LONG_LONG_MAX
const int N = 5e3+4;

int main()
{
    std::ios::sync_with_stdio(false),std::cin.tie(nullptr),std::cout.tie(nullptr);
    ll n,k;
    std::cin>>n>>k;
    std::vector<ll> v;
    v.push_back(-1);
    for (int i = 0; i < n; i ++)
    {
        ll num;
        std::cin>>num;
        v.push_back(num);
    }
    // l_to_r 记录每个数从左到右第一次出现的位置，r_to_l 则记录从右到左
    std::map<ll,ll> l_to_r,r_to_l;
    for (int i = 1; i <= n; i ++)
    {
        if (!l_to_r[v[i]]) l_to_r[v[i]] = i;
        r_to_l[v[i]] = n - i + 1;
    }
    ll ans = inf;
    // 情况 1：双左
    for (int i = 1; i <= n; i ++)
    {
        if (l_to_r.find(k-v[i]) != l_to_r.end())
        {
            ll time = std::max((l_to_r[v[i]]+1)/2,(l_to_r[k-v[i]]+1)/2);
            ans = std::min(ans,time);
        }
    }
    // 情况 2：左右
    for (int i = 1; i <= n; i++)
    {
        if (l_to_r.find(k-v[i]) != l_to_r.end())
        {
            ll mn1 = std::min(l_to_r[v[i]],r_to_l[v[i]]);
            ll mn2 = std::min(l_to_r[k-v[i]],r_to_l[k-v[i]]);
            ans = std::max(mn1,mn2);
        }
    }
    // 情况 2：双右
    for (int i = 1; i <= n; i ++)
    {
        if (l_to_r.find(k-v[i]) != l_to_r.end())
        {
            ll time = std::max((r_to_l[v[i]]+1)/2,(r_to_l[k-v[i]]+1)/2);
            ans = std::min(ans,time);
        }
    }
    if (ans == inf) std::cout<<-1<<'\n';
    else std::cout<<ans<<'\n';
    return 0;
}
```
- 结果还是没过，到这里其实就已经有点烦躁了
- 于是我稍微休息了一会儿，过一阵子等脑子不那么乱了再重新整理了一遍思路
- 然后分析一下之前的问题，终于是解决了

```cpp
#include <bits/stdc++.h>
#define ll long long
#define inf LONG_LONG_MAX
const int N = 2e5+5;
int a[N];

int main()
{
    std::ios::sync_with_stdio(false),std::cin.tie(nullptr),std::cout.tie(nullptr);
    ll n,k;
    std::cin>>n>>k;
    std::map<ll,ll> ltr,rtl;
    for (int i = 1; i <= n; i ++)
    {
        std::cin>>a[i];
        if (!ltr[a[i]]) ltr[a[i]] = i;
        rtl[a[i]] = n - i + 1;
    }
    ll ans = inf;
    // 从左往右依次拿
    for (int i = 1; i <= n; i ++)
    {
        if (ltr[a[i]] > n/2) break;
        if (ltr.find(k-a[i]) != ltr.end() && k - a[i] != a[i])
        {
            ll time = std::max(ltr[a[i]],ltr[k-a[i]]);
            ans = std::min(ans,time);
        }
    }

    // 从右往左依次拿
    for (int i = n ; i >= 1; i--)
    {
        if (rtl[a[i]] > n/2) break;
        if (rtl.find(k-a[i]) != rtl.end() && k - a[i] != a[i])
        {
            ll time = std::max(rtl[a[i]],rtl[k-a[i]]);
            ans = std::min(ans,time);
        }
    }

    // 左右同时拿
    for (int i = 1; i <= n; i ++)
    {
        if (ltr[a[i]] > n/2) break;
        if (ltr.find(k-a[i]) != ltr.end() && k - a[i] != a[i])
        {
            ll time1 = std::max(ltr[a[i]],rtl[k-a[i]]);
            ll time2 = std::max(ltr[k-a[i]],rtl[a[i]]);
            ans = std::min(ans,std::min(time1,time2));
        }
    }
    if (ans != inf) std::cout<<ans<<'\n';
    else std::cout<<-1<<'\n';
    return 0;
}
```