# 4432.农场主的挑战

在二分的过程中，我比较喜欢 mid = (left + right) >> 1 这种写法

当 left，right 逐渐收缩时，一旦二者成为邻值，那么 mid 就会被锁定在 left 而非 right
因此，right 应该设计为非法值（例如合法值+1），left 则应该是合法值

```cpp
#include <bits/stdc++.h>
const int N = 1e5+4;
int n, m;

bool check(int ans, std::vector<int>& v)
{
    int sum = 0;
    for (const auto& e:v) sum += e/ans;
    return sum >= n ? true : false;
}

int main()
{
    std::ios::sync_with_stdio(false),std::cin.tie(nullptr),std::cout.tie(nullptr);
    std::cin>>n>>m;
    std::vector<int> v(m);
    int max = 0;
    int sum = 0;
    for(auto &e: v)
    {
        std::cin>>e;
        max = std::max(e, max);
        sum += e;
    }
    if(n > sum)
    {
        std::cout<<"-1"<<'\n';
        return 0;
    }
    else if( n == sum )
    {
        std::cout<<1<<'\n';
        return 0;
    }
    else
    {
      int left = 1, right = max + 1;
      while (left + 1 != right)
      {
        int mid = (left + right) >> 1;
        if (check(mid, v)) left = mid;
        else right = mid;
      }
      std::cout<<left<<'\n';
      return 0;
    }
}
```