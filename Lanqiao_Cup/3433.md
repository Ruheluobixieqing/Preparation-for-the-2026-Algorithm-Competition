# 3433.一道简单的取模问题

可以直接使用 STL 容器中的 prioriry_queue

```cpp
#include<bits/stdc++.h>
#define ll long long
const int N = 2e5+3;
std::priority_queue<int> pq;

int main()
{
    std::ios::sync_with_stdio(false),std::cin.tie(nullptr),std::cout.tie(nullptr);
    ll n, q;
    std::cin >> n >> q;
    ll sum = 0;
    for (int i = 0; i < n; i++)
    {
        ll x;
        std::cin >> x;
        pq.push(x);
        sum += x;
    }

    for (int i = 0; i < q; i++)
    {
        ll mod;
        std::cin >> mod;

        while (pq.top() >= mod)
        {
            ll num = pq.top();
            pq.pop();
            sum -= num;
            num %= mod;
            sum += num;
            pq.push(num);
        }
        std::cout<< sum <<' ';
    }
    return 0;
}
```

手写堆比较复杂，主要是利用堆的父子结点间的数学关系进行联系和操作

```cpp
#include<bits/stdc++.h>
#define ll long long
const int N = 2e5+3;
ll a[N];
int sz;

void pushUp(ll x)
{
    if (x == 1) return;
    if (a[x] > a[x >> 1])
    {
        std::swap(a[x], a[x >> 1]);
        pushUp(x >> 1);
    }
}

void pushDown(ll x)
{
    if (x << 1 > sz) return;

    if (x << 1 == sz)
    {
        if (a[x << 1] > a[x])
        {
            std::swap(a[x], a[x << 1]);
            pushDown(x << 1);
        }
    }
    else
    {
        if (a[x] >= std::max(a[x << 1], a[x << 1 | 1])) return;

        if (a[x << 1] > a[x << 1 | 1])
        {
            std::swap(a[x], a[x << 1]);
            pushDown(x << 1);
        }
        else
        {
            std::swap(a[x], a[x << 1 | 1]);
            pushDown(x << 1 | 1);
        }
    }
}

void push(ll x)
{
    a[++sz] = x;
    pushUp(sz);
}

void pop()
{
    a[1] = a[sz--];
    pushDown(1);
}

int main()
{
    std::ios::sync_with_stdio(false),std::cin.tie(nullptr),std::cout.tie(nullptr);
    int n, q;
    std::cin >> n >> q;
    ll sum = 0;
    for (int i = 0; i < n; i++)
    {
        ll x;
        std::cin >> x;
        sum += x;
        push(x);
    }

    for (int i = 0; i < q; i++)
    {
        ll x;
        std::cin >> x;
        while (a[1] >= x)
        {
            ll num = a[1];
            sum -= num;
            pop();
            num %= x;
            sum += num;
            push(num);
        }
        std::cout << sum << ' ';
    }
    return 0;
}
```