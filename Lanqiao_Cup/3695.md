# 3695.聪明的小羊肖恩

这道题很容易想到两层 for 循环的暴力解法，可以过 65% 的样例

```cpp
#include <bits/stdc++.h>
#define ll long long
const int N = 2e5+4;
int a[N];

int main()
{
    std::ios::sync_with_stdio(false), std::cin.tie(nullptr), std::cout.tie(nullptr);
    int n, L, R;
    std::cin >> n >> L >> R;
    for (int i = 1; i <= n; i++) std::cin>>a[i];
    int ans = 0;
    for (int left = 1; left < n; left++)
    {
        for (int right = left + 1; right <= n; right++)
        {
            if (a[left] + a[right] <= R && a[left] + a[right] >= L) ans++;
        }
    }
    std::cout << ans << '\n';
    return 0;
}
```

下面是 AC 思路：

我们的目标是找到下标对的个数，需要满足 1 <= i < j <= n。所以原数组中各个元素的位置对最终结果的数量并没有影响，因此可以对数据进行排序 

L <= a_i + a_j <= R，即 L - a_i <= a_j <= R - a_i

只需要枚举 i 的同时二分定位 j 的上下界，时间复杂度 O(nlogn)

```cpp
#include <bits/stdc++.h>
#define ll long long
const int N = 2e5+4;
int a[N];

int main()
{
    std::ios::sync_with_stdio(false), std::cin.tie(nullptr), std::cout.tie(nullptr);
    int n, L, R;
    std::cin >> n >> L >> R;
    std::vector<int> v(n);
    for (auto &e: v) std::cin>>e;
    std::sort(v.begin(), v.end());
    ll ans = 0;
    for (int i = 0; i < n; i++)
    {
        int left = (int)(std::lower_bound(v.begin() + i + 1, v.end(), L - v[i]) - v.begin());
        int right = (int)(std::upper_bound(v.begin() + i + 1, v.end(), R - v[i]) - v.begin()) - 1;
        if ( right >= left ) ans += right - left + 1;
    }
    std::cout << ans << '\n';
    return 0;
}
```