# 3255.重新排队

用数组模拟双向链表

```cpp
#include<bits/stdc++.h>
const int N = 2e5+3;
int e[N], p[N], head, tail;


void delteNode(int idx)
{
    // idx 是结点下标
    // e[idx] 用于记录 idx 结点的下一个结点下标, p[idx] 用于记录 idx 结点的前一个结点下标
    // 如果 idx 是最后一个结点
    if (e[idx] == -1) e[p[idx]] = -1;
    else
    {
        e[p[idx]] = e[idx];
        p[e[idx]] = p[idx];
    }
}

void insertNode_front(int x, int y)
{
    // x 结点的下一个结点是 y，上一个结点是 p[y]
    e[x] = y;
    p[x] = p[y];

    // p[y] 的下一个结点是 x，y 的上一个节点是 x
    e[p[y]] = x;
    p[y] = x;
}

void insertNode_back(int x, int y)
{
    if (e[y] == -1)
    {
        e[x] = -1;
        p[x] = y;

        e[y] = x;
    }
    else
    {
        e[x] = e[y];
        p[x] = y;

        p[e[y]] = x;
        e[y] = x;
    }
}


int main()
{
    std::ios::sync_with_stdio(false),std::cin.tie(nullptr),std::cout.tie(nullptr);
    int n, m;
    std::cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        e[i] = i + 1;
        p[i] = i - 1;
    }
    e[0] = 1, e[n] = -1;

    for (int i = 1; i <= m; i++)
    {
        int x, y ,z;
        std::cin >> x >> y >> z;
        if (z)
        {
            // 将 x 移到 y 之前
            delteNode(x);
            insertNode_front(x, y);
        }
        else
        {
            // 将 x 移到 y 之后
            delteNode(x);
            insertNode_back(x, y);
        }
    }
    int idx = e[head];
    while (idx != -1)
    {
        std::cout<<idx<<' ';
        idx = e[idx];
    }
    return 0;
}
```