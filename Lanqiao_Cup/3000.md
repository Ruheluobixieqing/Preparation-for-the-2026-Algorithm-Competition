# 3000.神奇的数组

这题涉及位运算，确实没有什么思路

我在解析区找到了一个大神给出的方法


```cpp
//本题有三个难点：
//1、前缀数组的使用
//由于本题涉及到数组片段和，故想到使用前缀数组；对于异或同样存在类似的前缀数组
//故还应再设置一个异或数组yh[]，yh[i]保存从yh[0]到yh[i]连续异或的结果
//经过验算发现，对于从a[i]到a[j]的连续异或，等于对yh[i]和yh[j-1]求异或
//2、异或性质的理解
//异或的本质是模2加，即不带进位的二进制加法
//若一个序列模2加的结果等于普通加法的结果，说明任意两位都不发生进位
//则对于其任意一个子序列，其模2加的结果同样等于普通加法的结果
//故得到重要结论：若从a[i]异或到a[j]等于从a[i]累加到a[j]，则任取一个子序列，均满足此性质
//3、双指针的使用
//得出了如上重要结论后，不难想到双指针在本题的用法：
//若a[j]连续异或到a[i]等于a[j]加到a[i],则计数值直接加上此区间的长度即可，然后右端点i前移一个单位
//否则左端点j前移一个单位继续验证

#include <bits/stdc++.h>
#define ll long long

int main()
{
    std::ios::sync_with_stdio(false), std::cin.tie(nullptr), std::cout.tie(nullptr);
    int n;
    std::cin >> n;
    std::vector<int> v(n+1), prefix(n+1), prefix_xor(n+1);
    for (int i = 1; i <=n; i ++)
    {
        std::cin >> v[i];
        prefix[i] = prefix[i-1] + v[i];
        prefix_xor[i] = prefix_xor[i-1] ^ v[i];
    }

    ll ans = 0;
    for (int i = 1, j = 1; i <= n && j <= n; )
    {
        if ((prefix_xor[j] ^ prefix_xor[i - 1]) == (prefix[j] - prefix[i - 1]))
        {
            ans += j - i + 1;
            j ++;
        }
        else i++;
    }

    std::cout << ans << '\n';
    return 0;
}
```