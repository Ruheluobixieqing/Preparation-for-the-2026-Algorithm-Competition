# 185.修改数组

这题首先可以考虑暴力，直接用 set 容器记录存在与否，可以过 70% 的样例

这种方法时间复杂度主要受限于 while(st.count(a[i]))，因为有可能每次都要将整个 set 容器遍历一次

```cpp
#include <bits/stdc++.h>
#define ll long long
const int N = 1e5+3;
int a[N];

int main()
{
    std::ios::sync_with_stdio(false), std::cin.tie(nullptr), std::cout.tie(nullptr);
    int n;
    std::cin >> n;
    std::set<int> st;
    for (int i = 1; i <= n; i++)
    {
        std::cin >> a[i];
        while (st.count(a[i])) a[i]++;
        st.insert(a[i]);
        std::cout<< a[i] << ' ';
    }
    return 0;
}
```

采用并查集


```cpp
#include <bits/stdc++.h>
#define ll long long
const int N = 2e6+8;
int a[N], pre[N];

// 维护 root(i) 为 >= i 且不存在于 a[i ~ i - 1] 的数字
// 若 i 被使用，则 root(i) = root(i + 1)
// 始终保持由左侧指向右侧

int getRoot(int x)
{
    return pre[x] = (pre[x] == x ? x : getRoot(pre[x]));
}

int main()
{
    std::ios::sync_with_stdio(false), std::cin.tie(nullptr), std::cout.tie(nullptr);
    int n;
    std::cin >> n;
    for (int i = 1; i <= 2e6+3; i ++) pre[i] = i;
    for (int i = 1; i <= n; i++) std::cin >> a[i];
    for (int i = 1; i <= n; i++)
    {
        std::cout << getRoot(a[i]) << ' ';
        // 现在，getRoot(a[i]) 这个值被使用了,那么令 x = getRoot(a[i]),就有 pre[getRoot(x)] = getRoot(x + 1) 
        int x = getRoot(a[i]);
        pre[getRoot(x)] = getRoot(x + 1);
    }
    return 0;
}
```