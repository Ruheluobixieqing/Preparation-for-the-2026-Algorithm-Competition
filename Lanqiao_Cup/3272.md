# 3272.小蓝的漆房

- 第一遍想的比较简单，暴力枚举所有颜色即可
- 用 vector 存房子颜色，set 统计颜色种类，然后 for auto 一遍 set

```cpp
// 房子颜色总数最多不超过 60 种

#include <bits/stdc++.h>
const int N = 1e4 + 5;

void solve()
{
    int n,k;
    std::cin>>n>>k;
    std::vector<int> house(N);
    std::set<int>color;
    for(int i = 1; i <= n; i++)
    {
        int num;
        std::cin >> num;
        house[i] = num;
        color.insert(num);
    }
    int ans = INT_MAX;
    for(auto e : color)
    {
        int point = 1;
        int count = 0;
        while(point < n)
        {
            if(house[point] != e)
            {
                point += k;
                count ++;
            }
            else point += 1;
        }
        ans = std::min(count,ans);
    }
    std::cout<<ans<<'\n';
}

int main()
{
    std::ios::sync_with_stdio(false),std::cin.tie(nullptr),std::cout.tie(nullptr);
    int t;
    std::cin>>t;
    while(t--) solve();
    return 0;
}
```

- 提交发现有居然一半的样例没过？而且没有超时
- 检查了几遍感觉整体思路应该没有问题
- 于是我先重新审视了一遍输入，确保数据都正确读取了
- 没有办法，只能逐行排查问题
- 查到 while (point < n) 的时候发现了不对劲
- point 表示的应该是这一天将要从哪一个房子开始涂起
- 如果 point == n，也就是最后一个房子，那么还是要检查一下是不是需要重涂，这里漏掉了
- 改成 <= 即可

```cpp
// 房子颜色总数最多不超过 60 种

#include <bits/stdc++.h>
const int N = 1e4 + 5;

void solve()
{
    int n,k;
    std::cin>>n>>k;
    std::vector<int> house(N);
    std::set<int>color;
    for(int i = 1; i <= n; i++)
    {
        int num;
        std::cin >> num;
        house[i] = num;
        color.insert(num);
    }
    int ans = INT_MAX;
    for(auto e : color)
    {
        int point = 1;
        int count = 0;
        while(point <= n)
        {
            if(house[point] != e)
            {
                point += k;
                count ++;
            }
            else point += 1;
        }
        ans = std::min(count,ans);
    }
    std::cout<<ans<<'\n';
}

int main()
{
    std::ios::sync_with_stdio(false),std::cin.tie(nullptr),std::cout.tie(nullptr);
    int t;
    std::cin>>t;
    while(t--) solve();
    return 0;
}
```