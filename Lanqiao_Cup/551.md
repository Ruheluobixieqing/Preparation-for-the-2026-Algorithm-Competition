# 551.灌溉

- 这题给我的印象还是比较深的，以至于我总记得要开两个数组，一个用于记录当前的状态，另一个用于记录上一分钟的状态
- 核心就在于需要区分出，如果一个格子，其上下左右存在被灌溉好的格子，那么这个相邻的格子是本轮刚被灌溉的，还是已经被灌溉超过 1 min，即应该产生扩散
- 之前我也一直是按照开两个数组来做的，这次突然意识到其实可以记录一个格子被灌溉的时间，于是就有了以下做法:
- 对于一个格子，如果本轮刚被灌溉，则记为 0，若未灌溉，则保持 -1
- 对于一个格子，如果上一轮就已经被灌溉，即本轮初始状态即为 0，那么自增 1
- 这样就可以判断，如果一个未被灌溉的格子，其上下左右存在大于 0 的邻格，那么其应该被灌溉，否则不会被灌溉

```cpp
#include<bits/stdc++.h>
const int N = 1e2+3;
int arr[N][N];

bool check(int x,int y)
{
    if (arr[x-1][y] >0 || arr[x+1][y] > 0 || arr[x][y-1] >0 || arr[x][y+1] > 0) return true;
    else return false;
}


int main()
{
    std::ios::sync_with_stdio(false),std::cin.tie(nullptr),std::cout.tie(nullptr);

    // 初始化
    // 已经灌溉好的格子用 0,1,2,3,4... 表示，用来记录被灌溉了多久，未灌溉则用 -1 表示
    for (int i = 0; i < N; i++) for (int j = 0; j < N; j++) arr[i][j] = -1;

    int n,m,t;
    std::cin>>n>>m>>t;
    while (t -- )
    {
        int x,y;
        std::cin>>x>>y;
        arr[x][y] = 0;
    }
    int k;
    std::cin>>k;

    // 此时所有初始状态设置完成
    while (k--)
    {
        // 先更新所有已经灌溉的位置的时间
        for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) if (arr[i][j] >= 0) arr[i][j] ++;

        // 再处理即将被扩散的位置
        for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) if (arr[i][j] == -1 && check(i,j)) arr[i][j] ++;

        // for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) std::cout<<arr[i][j]<<" \n"[j==m];
    }

    int ans = 0;
    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) if (arr[i][j] >= 0) ans++;
    std::cout<<ans<<'\n';
    return 0;
}
```