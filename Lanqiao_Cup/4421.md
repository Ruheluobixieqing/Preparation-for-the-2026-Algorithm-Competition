# 4421.蓝桥实习生1

- 乍一看真觉得这就是个最基础的 if、else if 判断条件题目
- 无非是需要注意一下顺序问题
- 结果第一轮交上去有一个样例没过

```cpp
#include<bits/stdc++.h>
int main()
{
  double n,t;
  std::cin>>n>>t;
  double ans = 4000;
  if(n>=6)
  {
    if(t>=3.5) ans += (n-2)/2*200*20*1.4;
    else if(t>=3) ans += (n-2)/2*200*20*1.2;
    else if(t>=2.5) ans += (n-2)/2*200*20;
  }
  else if(n>=4)
  {
    if(t>=3) ans += 1100;
    else if(t>=2.5) ans += 900;
    else if(t>=2) ans += 700;
  }
  else if(n>=3) 
  {
    if(t>=3) ans += 500;
    else if(t>=2.5) ans += 400;
    else if(t>=2) ans += 300;
  }
  else if(n>=2&&t>=2.5) ans += 200;
  std::cout<<std::fixed<<std::setprecision(2)<<ans<<'\n';
  return 0;
}
```

- 我翻了一下别人提供的解析，虽然没有 C++ 版本的
- 然后得到了以下代码

```cpp
#include<bits/stdc++.h>
int main()
{
  double n,t;
  std::cin>>n>>t;
  int ans_ = 4000;
  double ans = 0;
  if(n>=2&&t>=2.5) ans = 200;
  if(n>=3) 
  {
    if(t>=3) ans = 500;
    else if(t>=2.5) ans = 400;
    else if(t>=2) ans = 300;
  }
  if(n>=4)
  {
    if(t>=3) ans = 1100;
    else if(t>=2.5) ans = 900;
    else if(t>=2) ans = 700;
  }
  if(n>=6)
  {
    if(t>=3.5) ans = (n-2)/2*200*20*1.4;
    else if(t>=3) ans = (n-2)/2*200*20*1.2;
    else if(t>=2.5) ans = (n-2)/2*200*20;
  }
  std::cout<<std::fixed<<std::setprecision(2)<<ans+ans_<<'\n';
  return 0;
}
```

- 这次居然就全过了，我其实不太懂为什么
- 于是我又把原来的代码改了一下

```cpp
#include<bits/stdc++.h>
int main()
{
  double n,t;
  std::cin>>n>>t;
  double base = 4000;
  double ans = 0;
  if(n>=6)
  {
    if(t>=3.5) ans = std::max(ans,(n-2)/2*200*20*1.4);
    else if(t>=3) ans = std::max(ans,(n-2)/2*200*20*1.2);
    else if(t>=2.5) ans = std::max(ans,(n-2)/2*200*20.0);
  }
  if(n>=4)
  {
    if(t>=3) ans = std::max(ans,1100.0);
    else if(t>=2.5) ans = std::max(ans,900.0);
    else if(t>=2) ans = std::max(ans,700.0);
  }
  if(n>=3) 
  {
    if(t>=3) ans = std::max(ans,500.0);
    else if(t>=2.5) ans = std::max(ans,400.0);
    else if(t>=2) ans = std::max(ans,300.0);
  }
  if(n>=2&&t>=2.5) ans = std::max(ans,200.0);
  std::cout<<std::fixed<<std::setprecision(2)<<ans+base<<'\n';
  return 0;
}
```

- 这次居然又全过了?
- 于是我重新理了一遍这个奖金的计算，发现了一个很重要的问题:出题数多≠奖金高
- 例如，根据题目要求，我的出题数 >= 6，但是平均出题质量却只有 2，那么最高一档的奖励我应该是拿不到的，但是可以退而求其次拿到 700 的奖励
- 如果按照我最开始的逻辑，那么就会导致直接没有奖金，这就是问题所在