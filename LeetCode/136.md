# 136.只出现一次的数字

这题当然可以用 STL 容器解决，或者对数组进行排序，但是这些方法要么时间复杂度超过了 O(n)，要么空间复杂度不为常量级别

其实我一开始是没什么思路了，于是看了一眼提示，think about XOR,刹那间茅塞顿开

由于原来的数组中，只有一个数字出现了一次，其余均出现了两次

那么假设 x = nums[0]，遍历 nums 并对每个元素做一遍异或运算就能得到最终结果

这里用到了异或运算的性质：交换律、结合律

A ^ B ^ A = A ^ A ^ B = (A ^ A) ^ B = 0 ^ B = B

显然，遍历数组后，x 将被消除为仅出现过一次的那个元素

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int x = nums[0];
        for(int i = 1;i <nums.size(); i++) x ^= nums[i];
        return x;
    }
};
```