# 3.无重复字符的最长子串

```cpp
// 双指针
// 假设已经找到了一段符合要求的区间 i ~ j
// 将 i ~ j 中的字符存入 map 容器
// 向后继续遍历下一个下标 k
// 如果 map[k] 为 0, 则可以继续延伸
// 如果 map[k] 为 1，那么这个区间到此为止
// 将 i 拨回到 k 第一出现的位置，然后 j 继续向后推进
// 整个过程中，结果取最大值即可
// 时间复杂度 O(n)

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.size() == 0) return 0;
        int i = 0, j = 0;
        int ans = 1;
        std::map<char, int> mp;
        mp[s[0]]++;
        for(int j = 1; j < s.size();)
        {
            if(mp[s[j]] == 0) 
            {
                mp[s[j]]++;
                j++;
                ans = std::max(ans, j - i);
            }
            else
            {
                // 否则，将 i 拨到 s[j] 第一次出现的那个位置的后一个
                while(s[i] != s[j]) 
                {
                    mp[s[i]]--;
                    i++;
                }
                mp[s[i]]--;
                i++;
                
                // 现在 i 位于第一个使得 j 合法的位置
                // 此时长度必然不可能是最长的
                mp[s[j]]++;
                j++;
            }
        }
        return ans;
    }
};
```