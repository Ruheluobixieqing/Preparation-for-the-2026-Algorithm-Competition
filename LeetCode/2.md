# 2.两数相加

我的思路比较简单，先扫一遍，找到较长的那个链表，然后将 l1 定义为较长的链表的头指针，l2 定义为较短的，然后逐位做加法即可

这种方式的好处在于不太需要额外空间，空间复杂度比较好

```cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode *p1 = l1, *p2 = l2;
        while(1)
        {
            if(p1 == nullptr && p2 != nullptr)
            {
                // 说明 l2 更长
                std::swap(l1, l2);
                break;
            }
            else if(p1 == nullptr && p2 == nullptr) break;
            else if(p1 != nullptr && p2 == nullptr) break;
            else
            {
                p1 = p1 -> next;
                p2 = p2 -> next;
            }
        }
        // 保证 l1 一定不是短的的那个链表
        p1 = l1, p2 = l2;
        int carry = 0;
        while(1)
        {
            p1 -> val = p1 -> val + p2 -> val + carry;
            if(p1 -> val >= 10)
            {
                carry = 1;
                p1 -> val -= 10;
            }
            else carry = 0;
            std::cout << p1 -> val << ' ';
            if(p2 -> next == nullptr) break;
            else p1 = p1 -> next, p2 = p2 -> next;
        }
        // 如果还有进位
        while(carry)
        {
            if(p1 -> next)
            {
                // 下一位不为空，可以直接加
                p1 = p1 -> next;
                p1 -> val += carry;
                if(p1 -> val >= 10) p1 -> val -= 10;
                else carry = 0;
            }
            else
            {
                // 没有下一位了，需要新建一个结点
                ListNode *nextNode = new ListNode(1);
                p1 -> next = nextNode;
                carry = 0;
            }
        }
        return l1;
    }
};
```

下面给出一个时间复杂度较好的方案，即用一个新的链表来存数据，思路基本还是一样的

```cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* head = new ListNode(0);
        ListNode* preNode = head;

        int carry = 0;
        while(l1 || l2 || carry)
        {
            int sum = carry;
            if(l1)
            {
                sum += l1 -> val;
                l1 = l1 -> next;
            }
            if(l2)
            {
                sum += l2 -> val;
                l2 = l2 -> next; 
            }
            
            carry = sum / 10;
            ListNode* nowNode = new ListNode(sum % 10);
            preNode -> next = nowNode;
            preNode = nowNode;
        }
        preNode = head -> next;
        delete head;
        return preNode;
    }
};
```