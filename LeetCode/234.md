# 234.回文链表

这题本身难度并不高，用什么方法做其实都可以，但是重点在于题目提出的一个进阶要求

即要在空间复杂度为 O(1) 的情况下解决问题，这就直接导致无法开一个新的链表或是使用任何 STL 容器去存储已经遍历过的结点值

那么就必须要考虑如何能够在不使用额外空间的情况下反向遍历链表

解析中给到了一个递归的方式：

如果当前结点不为空，则递归进入下一个结点，遇到空结点则停止并返回

每次返回前，若结点不为空，则可以获取当前结点的值，这个值的获取就是逆序的

只需要单独开一个全局指针，顺序遍历链表，然后使用递归函数递归调用到最后一个结点，每比较一次值，全局指针后移即可

这个思路非常巧妙，我倒是第一次遇见

```cpp
class Solution {
    ListNode *leftPointer;
public:    
    bool reverseList(ListNode* head)
    {
        if(head != nullptr)
        {
            if(!reverseList(head->next)) return false;
            if(head -> val != leftPointer -> val) return false;
            leftPointer = leftPointer -> next;
        }
        return true;
    }
    bool isPalindrome(ListNode* head) {
        if(!head) return false;
        leftPointer = head;
        return reverseList(head);
    }
};
```