# 15.三数之和

我想到的这个解法算是靠着提醒解决的，但是感觉时间复杂度还是比较高,需要优化一下

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        std::sort(nums.begin(), nums.end());
        std::vector<std::vector<int>> ans;
        if(nums[0] > 0 || nums[nums.size() - 1] < 0) return ans;
        for(int i = 0; i < nums.size() - 2 && nums[i] <= 0; i++)
        {
            //if(i > 0 && nums[i] == nums[i - 1]) continue;

            // 用 now_sum 表示剩下两个数的需要的和
            int now_sum = 0 - nums[i];
            for(int j = i + 1; j < nums.size() - 1; j++)
            {
                //if(nums[j] == nums[j - 1]) continue;
                int tar = now_sum - nums[j];
                std::cout << nums[i] << ' ' << nums[j] << '\n';
                auto left = std::lower_bound(nums.begin() + j + 1, nums.end(), tar);
                auto right = std::upper_bound(nums.begin() + j + 1, nums.end(), tar);
                if(left == right) continue;
                else 
                {
                    int r = right - nums.begin(), l = left - nums.begin();
                    std::vector<int> tmp;
                    tmp.push_back(nums[i]), tmp.push_back(nums[j]), tmp.push_back(nums[l]);
                    if(std::find(ans.begin(), ans.end(), tmp) == ans.end())ans.push_back(tmp);
                }
            }
        }
        return ans;
    }
};
```

可以用双指针优化一下，时间复杂度 O(N²),但是可以过

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        std::sort(nums.begin(), nums.end());
        std::vector<std::vector<int>> ans;
        if(nums[0] > 0 || nums[nums.size() - 1] < 0) return ans;
        for(int i = 0; i < nums.size() - 2 && nums[i] <= 0; i++)
        {
            if(i > 0 && nums[i - 1] == nums[i]) continue;
            // 用 now_sum 表示剩下两个数的需要的和
            int now_sum = -nums[i];
            int left = i + 1, right = nums.size() - 1;
            while(left < right)
            {
                if(nums[left] + nums[right] > now_sum)
                {
                    // 需要减小
                    right --;
                }
                else if(nums[left] + nums[right] < now_sum)
                {
                    // 需要增大
                    left ++;
                }
                else
                {
                    std::vector<int> tmp;
                    tmp.push_back(nums[i]), tmp.push_back(nums[left]), tmp.push_back(nums[right]);
                    ans.push_back(tmp);
                    left ++, right --;
                    while(left < right && nums[left - 1] == nums[left]) left ++;
                    while(left < right && nums[right + 1] == nums[right]) right --; 
                }
            }
        }
        return ans;
    }
};
```