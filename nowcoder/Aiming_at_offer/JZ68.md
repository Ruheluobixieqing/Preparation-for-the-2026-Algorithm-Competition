# JZ68.二叉搜索树的最近公共祖先

应该算是 JZ86 的特殊情况，代码可以直接照搬

```cpp
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param root TreeNode类 
     * @param p int整型 
     * @param q int整型 
     * @return int整型
     */
    TreeNode* ans = nullptr;
    std::map<TreeNode*, int> mp;
    int find(int o1, int o2, TreeNode* root)
    {
        int total = 0;
        if(root -> val == o1 || root -> val == o2) total ++;
        int left = 0, right = 0;
        if(root -> left) left = find(o1, o2, root -> left);
        if(root -> right) right = find(o1, o2, root -> right);
        if(total == 0 && left == right && left == 1) ans = root;
        else if(total == 1 && left + right == 1) ans = root;
        return total + left + right;
    }
    int lowestCommonAncestor(TreeNode* root, int p, int q) {
        find(p, q, root);
        return ans -> val;
    }
};
```