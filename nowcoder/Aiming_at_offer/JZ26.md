# JZ26.树的子结构

遍历树的时候判断结构是否吻合即可，需要注意的是，仅仅是判断子结构，而非子树，子树的要求比子结构更加严格

```cpp
class Solution {
public:
	bool findTree = false;
	bool judgeTree(TreeNode* root1, TreeNode* root2)
	{
		// 能够进入该函数，说明 root1 -> val = root2 -> val
		// root2 有的结构， root1 必须要有
		if((root2 -> left != nullptr && root1 -> left == nullptr)||(root2 -> right != nullptr && root1 -> right == nullptr)) return false;

		// root2 子节点的值， root1 必须相同
		bool left = true, right = true;
		if(root2 -> left) 
		{
			if(root1 -> left -> val != root2 -> left -> val) return false;
			left = judgeTree(root1 -> left, root2 -> left);
		}
		if(root2 -> right) 
		{
			if( root1 -> right -> val != root2 -> right -> val) return false;
			right = judgeTree(root1 -> right, root2 -> right);
		}
		return left && right;

	}
	void traverseTree(TreeNode* root1, TreeNode* root2)
	{
		if(findTree == true) return;
		if(root1 -> val == root2 -> val) findTree = judgeTree(root1, root2);
		if(root1 -> left) traverseTree(root1 -> left, root2);
		if(root1 -> right) traverseTree(root1 -> right, root2);
	}

    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) {
		if ( pRoot1 == nullptr || pRoot2 == nullptr) return false;
		traverseTree(pRoot1, pRoot2);
		return findTree;
    }
};
```