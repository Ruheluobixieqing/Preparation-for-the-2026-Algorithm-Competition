# JZ35.复杂链表的复制

用一个 map 存两个链表间的对应关系，遍历两次，第一次构造新链表的 label，第二次构造新链表的 random

```cpp
class Solution {
public:
    RandomListNode* Clone(RandomListNode* pHead) {
        if(pHead == nullptr) return nullptr;

        std::map<RandomListNode*, RandomListNode*> mp;
        
        RandomListNode* p1 = pHead;
        RandomListNode* head = new RandomListNode(p1 -> label);
        p1 = p1 -> next;
        RandomListNode* p = head;

        while(p1)
        {
            RandomListNode* newNode = new RandomListNode(p1 -> label);
            mp[p1] = newNode;
            p -> next = newNode;
            p = p -> next;
            p1 = p1 -> next;
        }

        for(const auto &e: mp) std::cout << e.first << ' ' << e.second << '\n';

        p = head, p1 = pHead;
        while(p1)
        {
            if(p1->random == nullptr) p -> random = nullptr;
            else p -> random = mp[p1->random];
            p = p -> next;
            p1 = p1 -> next;
        }

        return head;
    }
};
```