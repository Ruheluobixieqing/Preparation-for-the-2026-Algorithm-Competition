# JZ52.两个链表的第一个公共结点

第一种思路，先遍历一遍一个链表，将地址依次存入 set 容器，然后遍历第二个链表，每次查询是否出现过即可

```cpp
class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        std::set<ListNode*> st;
		ListNode* p1 = pHead1;
		while(p1)
		{
			st.insert(p1);
			p1 = p1 -> next;
		}
		ListNode* p2 = pHead2;
		while(p2)
		{
			if(st.count(p2)) return p2;
			else p2 = p2 -> next;
		}
		return nullptr;
    }
};
```

第二种思路，双指针，走一遍自己的和对方的，如果始终没有相遇，说明没有公共结点

```cpp
class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        ListNode *p1 = pHead1, *p2 = pHead2;
		if((p1 == nullptr && p2 != nullptr)||(p1 != nullptr && p2 == nullptr)) return nullptr;
		bool find = true;
		while(1)
		{	
			if(p1 == p2) return p1;
			if(p1 -> next != nullptr) p1 = p1 -> next;
			else
			{
				p1 = pHead2;
				if(find) find = false;
				else return nullptr;
			}
			if(p2 -> next != nullptr) p2 = p2 -> next;
			else p2 = pHead1;
		}
    }
};
```