# JZ33.二叉搜索树的后序遍历序列

这题的思路其实参考的是 JZ7，都是递归调用原函数进行判断，可以单独开一个全局变量 ans 用于记录最终结果

```cpp
class Solution {
public:
    bool ans = false;
    bool VerifySquenceOfBST(vector<int> sequence) {
        int n = sequence.size();
        if(n == 0 || n == 1) return n;
        for(int i = 0; i < n; i++)
        {
            if(sequence[i] < sequence[n-1]) continue;
            // 找到第一个 >= sequence[n-1] 的结点
            if(i == n-1)
            {
                // 说明没有右子树
                std::vector<int> left_sequence(sequence.begin(), sequence.begin() + i);
                ans = VerifySquenceOfBST(left_sequence);
            }
            else if(i == 0)
            {
                // 说明没有左子树
                std::vector<int> right_sequence(sequence.begin(), sequence.end() - 1);
                // 必须保证右侧所有元素都大于根结点
                for(const auto &e : right_sequence) if(e < sequence[n-1]) return false;
                ans = VerifySquenceOfBST(right_sequence);
            }
            else 
            {
                std::vector<int> left_sequence(sequence.begin(), sequence.begin() + i);
                std::vector<int> right_sequence(sequence.begin() + i, sequence.end() - 1);
                for(const auto &e : right_sequence) if(e < sequence[n-1]) return false;
                ans = VerifySquenceOfBST(left_sequence) && VerifySquenceOfBST(right_sequence);
            }
            break;
        }
        return ans;
    }
};
```