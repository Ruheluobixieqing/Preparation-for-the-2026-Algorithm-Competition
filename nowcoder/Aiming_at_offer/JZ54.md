# JZ54.二叉搜索树的第 k 个结点

这题我一开始没看清题目，以为是任意一棵树，导致我忽略掉了二叉搜索树的重要性质：中序遍历会得到升序序列，那么便利到第几个就是第几小的值了

```cpp
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param proot TreeNode类 
     * @param k int整型 
     * @return int整型
     */
    int ans = 0;
    std::priority_queue<int> pq;
    int getSize(TreeNode* root)
    {
        if(root == nullptr) return 0;
        return 1 + getSize(root -> left) + getSize(root -> right);
    }
    void find(TreeNode* root, int* num, int k)
    {
        // 中序遍历（左中右）
        if(root -> left != nullptr) find(root -> left, num, k);
        (*num) ++;
        if(*num == k) ans = root -> val;
        std::cout<< *num << '\n';
        if(root -> right != nullptr) find(root -> right, num, k);
    }
    int KthNode(TreeNode* proot, int k) {
        int n = getSize(proot);
        if(n == 0 || k > n || k == 0) return -1;
        int num = 0;
        find(proot, &num, k);
        return ans;
    }
};
```

这里还是附上我白想了很久的思路：

用优先队列维护前 k 小的值，然后遍历树

```cpp
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param proot TreeNode类 
     * @param k int整型 
     * @return int整型
     */
    std::priority_queue<int> pq;
    int getSize(TreeNode* root)
    {
        if(root == nullptr) return 0;
        return 1 + getSize(root -> left) + getSize(root -> right);
    }
    void traverseTree(TreeNode* root, int k)
    {
        if(root == nullptr) return;
        if(pq.size() < k) pq.push(root->val);
        else if(root->val < pq.top())
        {
            pq.pop();
            pq.push(root->val);
        }
        if(root -> left != nullptr) traverseTree(root -> left, k);
        if(root -> right != nullptr) traverseTree(root -> right, k);

    }
    int KthNode(TreeNode* proot, int k) {
        int n = getSize(proot);
        if(n == 0 || k > n || k == 0) return -1;
        traverseTree(proot, k);
        return pq.top();
    }
};
```