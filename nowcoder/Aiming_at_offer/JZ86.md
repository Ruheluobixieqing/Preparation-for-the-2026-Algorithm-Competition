# JZ86 在二叉树中找到两个节点的最近公共祖先

```cpp
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param root TreeNode类 
     * @param o1 int整型 
     * @param o2 int整型 
     * @return int整型
     */
    TreeNode* ans = nullptr;
    int find(int o1, int o2, TreeNode* root)
    {
        int total = 0;
        if(root -> val == o1 || root -> val == o2) total ++;
        int left = 0, right = 0;
        if(root -> left) left = find(o1, o2, root -> left);
        if(root -> right) right = find(o1, o2, root -> right);
        if(total == 0 && left == right && left == 1) ans = root;
        else if(total == 1 && left + right == 1) ans = root;
        return total + left + right;
    }
    int lowestCommonAncestor(TreeNode* root, int o1, int o2) {
        find(o1, o2, root);
        return ans -> val;
    }
};
```